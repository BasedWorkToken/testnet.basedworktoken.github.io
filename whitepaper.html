<!--This is the whitepaper page, it is created to show users our intent for the project-->
<!doctype html>
<html lang="en" class="no-js">
<head>
  
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="canonical" href="https://html5-templates.com/" />
    <title>Based Work Token</title>
<meta name="description" content="Based Work Token Token is a decentralized bitcoin inspired proof-of-work contract on the Base Blockchain.  View this webpage for the Whitepaper">


	    <!-- Open Graph meta tags for social media previews -->
    <meta property="og:title" content="Based Work Token Whitepaper">
    <meta property="og:description" content="Based Work Token Whitepaper page. View webpage to see the Whitepaper.">
    <meta property="og:image" content="https://www.basedworktoken.org/img/zkBitcoin.png">
    <meta property="og:url" content="https://basedworktoken.org/whitepaper.html">
    <meta property="og:type" content="website">


    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/modern-business.css" rel="stylesheet">
    <link href="font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link href="css/rounded-icons.css" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>

<body>    
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html" target="_self" aria-label="FORGE"><img alt="BWORK" src="img/forgeprofile circle-02.png" width="100px" height="110px" class="img-responsive"></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right"> <li>
                        <a href="/" style="font-size:1.1em">Home</a>
                    </li>
                  <li>
                    <a href="https://syncswap.xyz/swap?outputCurrency=0x366d17aDB24A7654DbE82e79F85F9Cb03c03cD0D" style="font-size:1.1em">Buy Based Work</a>
                </li>
                    <li>
                        <a href="stats.html"style="font-size:1.1em">Token Stats</a>
                    </li>
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" style="font-size:1.25em">BWORK dAPPs<b class="caret"></b></a>
                        <ul class="dropdown-menu">

				    <li>
				        <a href="0xBitcoin_Converter.html" style="font-size:1.1em">0xBitcoin Converter dAPP</a>
				    </li>
                        </ul>
                    </li>  
                    <!--an ordered list stan made me remove 3 times-->
                   <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" style="font-size:1.25em">BWORK Instructions<b class="caret"></b></a>
                        <ul class="dropdown-menu">

                            <li>
                                <a href="whitepaper.html"style="font-size:1.1em">Whitepaper</a>
                            </li>

                            <li>
                                <a href="howtoconvert.html"style="font-size:1.1em">How to Convert 0xBitcoin to BWORK</a>
                            </li>
                            <li>
                                <a href="howtomine.html"style="font-size:1.1em">How to Mine</a>
                            </li>
                            <li>
                                <a href="team.html"style="font-size:1.1em">Contact Us</a>
                            </li>
                        </ul>
                    </li>
                        </ul>
            </div>
            <!-- class /.navbar-collapse -->
        </div>
        <!-- class /.container -->
    </nav>
    
    <!-- Header Carousel -->
		    <header id="myCarousel" class="carousel slide">
    <div class="banner-container">
  <img src="img/banner_orange.png" alt="Banner" class="banner-image">
</div>
  <div class="corner-image-container"></div> <!-- Div with the new class -->
</div>
    </header>
            <div class="col-lg-12" style="text-align: center;">
                <h2 class="page-header">White Paper</h2>
            </div>
        <!--whitepaper start, "h" tags are headers, and "pre" tags are pre formatted information-->
        <div style="padding:0% 5% 5% 5%;">

<h2 id="zkBitcoin-token">Based Work Token</h2>
<h4 id="-whitepaper-revision-1-0-17-">( Whitepaper Revision 0.0.03 )</h4>
<h4 id="zkBitcoin-token-the-decentralized-bitcoin-token-for-zkSync-Era">Based Work Token : The Decentralized Bitcoin Token for Based Blockchain</h4>
<hr>
<h3 id="abstract">Abstract</h3>
<p>The Based Network has launched as the a leading layer 2 solution to Ethereum and has a world class leading ecosystem for permissionless, transparent, and immutable software applications.  These software applications, typically taking the form of Smart Contracts, can all seamlessly interact with each other.  To facilitate this process, various standard protocols have been developed such as the ERC20 standard for a common ‘token’ format so that these Smart Contracts can pass scarce, owned, and transferable data between one another without a centralized mediator.  Most ERC20 tokens have been distributed in a matter that is generally known to align with ‘securities.’  The tokens are sold to ‘investors’ by the ‘creator’ under the pretenses that the ‘creator’ will perform some action to make the tokens more valuable.  It should be clarified that Bitcoin is distributed via ‘bitcoin mining’ and therefore aligns itself as a ‘commodity’ and not a ‘security.’  This whitepaper will describe a ERC20 token that aligns itself as a ‘commodity’ since it is distributed using ‘Proof of Work Mining’.  This token is also transferred on a blockchain in a method very similar to Bitcoin and so therefore interfaces with other software and with the world in a manner which is effectively similar to Bitcoin.  This token has several advances that set it apart from Bitcoin such as the ability to directly interact with Base Blockchain Smart Contracts and the rest of the Base Ecosytem in a permissionless way.</p>
<h3 id="background">Background</h3>
<p>Based Work Token is the implementation of Bitcoin in Solidity.  It is an open source community project, not led by an official team or corporation, and therefore does not have ICO capital or other vast amounts of currency/capital that a centralized token project would have.  We believe as a community that decentralization is the true flavor of the blockchain and that is the architecture that provides open and transparent trust for users.   We also believe that Base Blockchain and ERC20 tokens are a significant segment of the future of blockchain technology.</p>
<p>Based Work Token is designed to be used as a decentralized ‘bitcoin-like’ token within the Base ecosystem and beyond. All tokens are minted on the Base Blockchain.  Based Work Token follows a standard protocol (ERC20), tokens are stored on the Based Blockchain address and it is transferred using standard software which supports EIP20/ERC20 tokens.   Since zkBitcoin Tokens are mined in a completely decentralized manner, there is no central body or central organization which controls or enforces any aspect of Based Work Token.  The community owns and operates the token in a flat structure and every individual has the same power over the smart contract as any other individual.  This is on purpose in order to follow the same model of Bitcoin and to establish zkBitcoin Token as a commodity.  </p>
<p>One of the most effective side effects of Satoshi Nakamoto&#39;s desire to secure the original Bitcoin network with Proof of Work hash mining was tethering and bootstrapping the coin to computing power, thereby removing centralized actor jurisdiction. Transitioning the responsibility of work back onto individual miners, government organizations would have no jurisdiction, and indeed visibility, of mined Based Work Token. Government oversight is removed from an equation whereby miners are providing economic effort in direct exchange of a cryptographic commodity.  This facilitates relatively decentralized distribution and establishes all involved parties as stakeholders.  Based Work Token (BWORK) is a token that allows projects to be funded not by centralized, direct-fiat conversion, but through decentralized computing power.</p>
<h3 id="name-origin-of-zkBitcoin-token">Name Origin of Based Work Token</h3>
<p>The name Based Work Token is derived from the fact it is a token that is able to be mined using Proof of work and the layer 2 we are on Base.</p>
<p>The symbol BWORK is from a combination of the term ‘Based’ which implies that the asset lives on the Base Blockahin layer 2 and WORK for Proof of WOrk since Bitcoin is called a proof of work model.  </p>
<p>The Based Work Token contract is located at Base address <a href="https://sepolia.basescan.org/address/0x158A9607FaE8ae0754eF39dE978eA4751A4C6d1f">0x158A9607FaE8ae0754eF39dE978eA4751A4C6d1f</a> and has validated transparent code which can be audited on the Base Blockchainservice.  </p>
<h3 id="proof-of-work-and-icos">Proof of Work and ICOs</h3>
<p>The Base blockchain in its current state exists as a thriving permissionless ecosystem which allows any individual to store immutable records in a permissionless, invulnerable and transparent manner.  As blockchain applications become richer and more numerous, there is a need for alternative distribution models than the ICO. Indeed, there have been proposals to mitigate some  initial investment risks through the recent introduction of the DAICO model (Cunningham, 2018) that rely on timed and automated value transfers via the DIACO smart contract tapping mechanism. However, this does not align a token smart contract as a non-security and still has the potential to put investors at risk if not implemented carefully. Allowing users of the network direct access to tokens by performing computations as a proof of work supplies allows any smart contract to distribute a token in a safe, slow, and controlled manner similar to the release of a new commodity.</p>
<p>As of 2023, most all Ethereum Virtual Machine token distribution methods were flawed and able to be Sybil attacked.  A Sybil attack is a form of computer security attack in which one human pretends to be many humans with multiple computer accounts in order to manipulate a system in a malicious way.  ICOs and airdrops are highly susceptible to Sybil Attacks and since there is no way to verify that all ERC20 tokens distributed by the deployer distributed fairly or unfairly.  Based Work Token, with its unique Proof of Work distribution method, is resistant to Sybil attacks.  This means that zkBitcoin Token is used as a trustless EVM token in the world.  It can be argued that the distribution of Based Work Token is fair since it was only distributed by mathematical hashing and not by a human.</p>
<h3 id="current-and-proposed-use-cases">Current and Proposed Use Cases</h3>
<p>As an implementation of the original Bitcoin software as an Base Blockchain Smart Contract, Based Work Token (or BWORK) combines advantages from both Bitcoin, Ethereum and Base Blockchain Layer 2.  The asset is decentralized, permissionless, mined and scarce just like Bitcoin which means it shares all of Bitcoin’s usecases and properties as a transparent and permanent digital record of value.  However, above Bitcoin, Based Work Token Token has the speed and scalability of the Base Blockchain network and is compatible with all ERC20 token services.  This means it can be stored in any EVM wallet, is as secure as Base blockchain, and can act as ‘the bitcoin’ for the ecosystem.  This is important because Bitcoin is not able to communicate with or interact with the EVMs of Ethereum or Layer 2s.  With Based Work Token, the Base network is now effectively upgraded with the ability to interface with a commodity which shares all of the same properties as Bitcoin.  Now, all zkSync Era smart contracts can hold, transfer, and trade bitcoin-like tokens permissionlessly and can do so based on immutable rules set forth using their own computer code.</p>
<h3 id="the-decentralized-token">The Decentralized Token</h3>
<p>Since Based Work Token is mined like Bitcoin, it acts just like a commodity.  The difficulty of ‘mining’ this commodity automatically adjusts to the total computational power used to mine it.  The current state of the EVM ICO market with its demonstrable failure rate leaves investors vulnerable to holding pseudo-value backed only by speculation. Based Work Token mitigates this problem by providing the zkSync Era blockchain network with a decentralized bitcoin-like asset which is able to fill the role of a multitude of centralized tokens in a more invulnerable and trustless format.</p>
<p>This powerful mechanism frees individuals from having to use a third party exchange, susceptible to security holes and wallet compromise, and third party escrows. The movement away from centralization is a core tenant of what Satoshi Nakamoto originally intended with classic Bitcoin (Nakamoto, 2009).  Based Work Token has the facilities to help keep the Ethereum ecosystem open, accountable, trustless and decentralized at every step in the value transfer process.  Unlike Bitcoin, Based Work Token can interact decentralzied exchanges such as Uniswap, Sushiswap, and is compatible with zkSync Era smart contracts.  This means that while Bitcoin can only be traded using centralized means, Based Work Token can be traded permissionlessly within immutable permanent smart contracts which are not able to be censored or restricted by central entities.  This is another clear advantage and is closer to fulfilling Satoshi’s complete vision. </p>
<h3 id="account-system">Account System</h3>
<p>As an ERC20 token, Based Work Token uses a traditional Base Blockchain account. These accounts are free and are impossible to hack or to steal from, given that the private key has not been exposed.  Based Work Token can be stored in a Ledger Nano, Trezor or any other wallet that supports ERC20 tokens.  </p>
<h2 id="mining">Mining</h2>
<p>Based Work Token is mined using a simple Keccak256 (Sha3) algorithm using the following methodology:</p>
<pre><code class="lang-js">   keccak256(challengeNumber, minerEthAddress, <span class="hljs-name">nonce</span>) &lt; difficultyTarget
</code></pre>
<p>The nonce is a random number selected by the mining software.  The mining software mines to try to find a valid nonce.  If the above statement evalutates to true, then the nonce is a valid solution to the proof of work.   The challengeNumber is just a recent zkSync Era block hash.  Every round, the challengeNumber updates to the most recent Base Blockchain block hash so future works cannot be mined in the past.  The miner&#39;s address is part of the hashed solution so that when a nonce solution is found, it is only valid for that particular miner and man in the middle attacks cannot occur.  This also enables pool mining.</p>
<p>When mining Based Work Token, whenever a miner submits a solution, the miner must pay a small gas fee in order to execute the zkSync Era smart contract code for the mint() function.  </p>
<h2 id="smart-contract">Smart Contract</h2>
<p>Typically, ERC20 tokens will grant all tokens to the owner or will have an ICO which demands that amounts of Ether be sent to the owner for an initial offering of tokens.  Instead of granting tokens to the &#39;contract owner&#39;, all Based Work Tokens are locked within the smart contracts initially. These tokens are dispensed, 50 at a time, by calling the function &#39;mint&#39; and using Proof of Work, similar to mining bitcoin classic. Also the following Smart Contract methods are explicitly supported:</p>
<h2 id="token">Token</h2>
<h3 id="erc-20-interface">ERC-20 Interface</h3>
<h4 id="name">name</h4>
<p>Returns the name of the token - e.g. <code>&quot;Based Work Token&quot;</code>.</p>
<p>OPTIONAL - This method can be used to improve usability,
but interfaces and other contracts MUST NOT expect these values to be present.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">string</span> <span class="hljs-keyword">name</span>)</span></span>
</code></pre>
<h4 id="symbol">symbol</h4>
<p>Returns the symbol of the token. e.g. <code>&quot;BWORK&quot;</code>.</p>
<p>OPTIONAL - This method can be used to improve usability,
but interfaces and other contracts MUST NOT expect these values to be present.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">symbol</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">string</span> symbol)</span></span>
</code></pre>
<h4 id="totalsupply">totalSupply</h4>
<p>Returns the total token supply.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalSupply</span><span class="hljs-params">()</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint256 totalSupply)</span></span>
</code></pre>
<h4 id="balanceof">balanceOf</h4>
<p>Returns the account balance of another account with address <code>_owner</code>.</p>
<pre><code class="lang-js">function balanceOf(<span class="hljs-name">address</span> _owner) constant returns (<span class="hljs-name">uint256</span> balance)
</code></pre>
<h3 id="mining-operations">Mining Operations</h3>
<h4 id="mint">mint</h4>
<p>Once verified, the mint function calculates and delivers a mining reward to the sender and performs internal accounting operations on the contract&#39;s supply.</p>
<pre><code class="lang-js">function mint(<span class="hljs-name">uint256</span> nonce, bytes32 challenge_digest) public returns (<span class="hljs-name">bool</span> success)
</code></pre>
<h4 id="mint">multiMint_SameAddress</h4>
<p>Allows multiple solutions (array of nonce), for the current challengeNumber.  As long as there are still blocks left to be mined in this readjustment it will accept the array and check validitiy and pay out the appropriate amount of tokens in one bundled transaction to save transaction fees instead of having single mints.</p>
<pre><code class="lang-js">function multiMint_SameAddress(<span class="hljs-name">address</span> mintToAddress, <span class="hljs-name">uint256 []</span> nonce) public
</code></pre>

<h5 id="-mint-event-"><em>Mint Event</em></h5>
<p>Upon successful verification and reward the mint method dispatches a Mint Event indicating the reward address, the reward amount, the epoch count and current challenge number.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Mint</span>(<span class="hljs-params">address indexed <span class="hljs-keyword">from</span>, <span class="hljs-keyword">uint</span> reward_amount, <span class="hljs-keyword">uint</span> epochCount, bytes32 newChallengeNumber</span>)</span>;
</code></pre>

<h4 id="getchallengenumber">getChallengeNumber</h4>
<p>Recent zkSync Era block hash, used to prevent pre-mining future blocks.  This is the current challenge we are solving.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChallengeNumber</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(bytes32)</span></span>
</code></pre>
<h4 id="getminingdifficulty">getMiningDifficulty</h4>
<p>The number of digits that the digest of the PoW solution requires which typically auto adjusts during reward generation.Return the current reward amount. Depending on the algorithm, typically rewards are divided every reward era as tokens are mined to provide scarcity.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMiningDifficulty</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span></span>
</code></pre>
<h4 id="getminingreward">getMiningReward</h4>
<p>Return the current reward amount.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMiningReward</span><span class="hljs-params">()</span> <span class="hljs-title">public</span> <span class="hljs-title">constant</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span></span>
</code></pre>
<h3 id="mining-debug-operations">Mining Debug Operations</h3>
<h4 id="getmintdigest">getMintDigest</h4>
<p>Returns a test digest using the same hashing scheme used when minting new tokens.</p>
<pre><code class="lang-js">function getMintDigest(<span class="hljs-name">uint256</span> nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (<span class="hljs-name">bytes32</span> digesttest)
</code></pre>
<p>OPTIONAL - This method can be used to improve usability,
but interfaces and other contracts MUST NOT expect these values to be present.</p>
<h4 id="checkmintsolution">checkMintSolution</h4>
<p>Verifies a sample solution using the same scheme as the mint method.</p>
<pre><code class="lang-js"><span class="hljs-built_in">function</span> checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, <span class="hljs-built_in">uint</span> testTarget) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">bool</span> success)
</code></pre>
<p>OPTIONAL - This method can be used to improve usability.
but interfaces and other contracts MUST NOT expect these values to be present.</p><h4 id="checkmintsolution">checkMintSolutionForAddress</h4>
<p>Verifies a sample solution using the same scheme as the mint method.</p>
<pre><code class="lang-js"><span class="hljs-built_in">function</span> checkMintSolution2(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, <span class="hljs-built_in">uint</span> testTarget, address sender) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">bool</span> success)
</code></pre>
<p>OPTIONAL - This method can be used to improve usability.</p>
<h2 id="minting-new-zkBitcoin-tokens">Minting New Based Work Tokens</h2>
<p>The Based Work Token was deployed to the Base blockchain in December, 2024, with the following attributes:</p>
<ul>
<li>1:1 Transfer of 0xBitcoins to Based Work Tokens</li>
<li>No ICO</li>
<li>21,000,000 tokens total supply</li>
<li>Difficulty target auto-adjusts with PoW hashrate</li>
<li>Rewards decrease as more tokens are minted</li>
<li>ERC20 compatibility</li>
</ul>
<p>As such, the only way for a user to acquire Based Work Tokens is to mine them or purchase them from miners on decentralized exchanges. The mintTo and multiMint_SameAddress functions is responsible for verifying the validity of the hash solution, updating the contracts internal state and issuing new Based Work Token.  They are shown below</p>
<pre><code class="lang-js">
        <span class="hljs-function">function <span class="hljs-title">mintTo</span>(<span class="hljs-params">uint256 nonce, address mintToAddress</span>) <span class="hljs-keyword">public</span> </span>{
            bytes32 localChallengeNumber = challengeNumber;
            bytes32 digest = keccak256(abi.encodePacked(localChallengeNumber, msg.sender, nonce));

            uint localDigestINT = uint256(digest);
            uint localMiningTarget = miningTarget;
	
            <span class="hljs-comment">//the digest must be smaller than the target</span>
            require(localDigestINT &lt; localMiningTarget, <span class="hljs-string">"Digest must be smaller than miningTarget"</span>);

            <span class="hljs-comment">//ensure this combination has not been used before</span>
            require(!usedCombinations[localChallengeNumber][digest], <span class="hljs-string">"Must not have been the first time this solve has been used"</span>);
            usedCombinations[localChallengeNumber][digest] = true;

           	uint multiplier_local = localMiningTarget / localDigestINT;
           	uint compensation = calculateCompensation(multiplier_local);
           	uint local_epoch_cnt = epochCount;
           	_startNewMiningEpoch_MultiMint_Mass_Epochs(compensation, blocksToReadjust());
           	local_epoch_cnt = epochCount - local_epoch_cnt;
           	uint localreward = local_epoch_cnt*reward_amount;
           	<span class="hljs-comment">// Check for max supply and adjust reward era and amount if needed</span>
            <span class="hljs-keyword">if</span> (tokensMinted.<span class="hljs-keyword">add</span>(localreward) &gt; maxSupplyForEra && rewardEra &lt; 59) {
                rewardEra = rewardEra + 1;
                maxSupplyForEra = _totalSupply - _totalSupply.<span class="hljs-keyword">div</span>(2 ** (rewardEra + 1));
                reward_amount = (50 * 10**18) / (2 ** (rewardEra));
                localreward = localreward.<span class="hljs-keyword">div</span>(2);
            }

            _mint(mintToAddress, localreward);

            tokensMinted = tokensMinted.<span class="hljs-keyword">add</span>(localreward);

            <span class="hljs-function">emit <span class="hljs-title">Mint</span>(<span class="hljs-params">msg.sender, localreward, epochCount, localChallengeNumber</span>)</span>;
        }
    </code>
</pre>
The only way to MultiMint is using the multiMint_SameAddress function.  Which is shown below.
<pre><code class="lang-js">
        <span class="hljs-function">function <span class="hljs-title">multiMint_SameAddress</span>(<span class="hljs-params">address mintToAddress, uint256[] memory nonce</span>) <span class="hljs-keyword">public</span> </span>{
           uint NextEpochCount = blocksToReadjust();
           uint xLoop = 0;
           uint GoodLoops = 0;
           bytes32 localChallengeNumber=challengeNumber;
           uint localMiningTarget = miningTarget;
		
            <span class="hljs-keyword">for</span> (xLoop = 0; xLoop &lt; nonce.length; xLoop++) {
                bytes32 digest = keccak256(abi.encodePacked(localChallengeNumber, msg.sender, nonce[xLoop]));
                uint localDigestINT = uint256(digest);
		    
                <span class="hljs-keyword">if</span> (usedCombinations[localChallengeNumber][digest] || uint256(digest) &gt;= localMiningTarget) {
                    <span class="hljs-keyword">continue</span>;
                }
                uint multiplier_local = localMiningTarget / localDigestINT;
                uint compensation = calculateCompensation(multiplier_local);
                GoodLoops = GoodLoops.<span class="hljs-keyword">add</span>(compensation);
		    
                usedCombinations[localChallengeNumber][digest] = true;
		  

                GoodLoops = GoodLoops.<span class="hljs-keyword">add</span>(1);
                
                usedCombinations[digest] = true;
                <span class="hljs-keyword">if</span> (GoodLoops >= NextEpochCount) {

                    GoodLoops = NextEpochCount;
                    <span class="hljs-keyword">break</span>;
                    }
                }
            

            _startNewMiningEpoch_MultiMint_Mass_Epochs(GoodLoops, NextEpochCount);

            uint payout = GoodLoops * reward_amount;

            <span class="hljs-comment">// Check for max supply and adjust reward era and amount if needed</span>
            <span class="hljs-keyword">if</span> (tokensMinted.<span class="hljs-keyword">add</span>(payout) &gt; maxSupplyForEra && rewardEra &lt; 59) {
                rewardEra = rewardEra + 1;
                maxSupplyForEra = _totalSupply - _totalSupply.<span class="hljs-keyword">div</span>(2 ** (rewardEra + 1));
                reward_amount = (50 * 10**18) / (2 ** (rewardEra));
                payout = payout.<span class="hljs-keyword">div</span>(2);
            }
            _mint(mintToAddress, payout);

            <span class="hljs-function">emit <span class="hljs-title">Mint</span>(<span class="hljs-params">msg.sender, payout, epochCount, localChallengeNumber</span>)</span>;    
            
            tokensMinted = tokensMinted.<span class="hljs-keyword">add</span>(payout);

        }
    </code>
</pre>

<p><em>figure 1. Based Work Token Smart Contract mintTo() function</em></p>
<p><em>figure 2. Based Work Token Smart Contract multiMint_SameAddress() function</em></p>
<p>The mining reward is initially gathered and follows the same algorithm as Bitcoin classic. Essentially following the paradigm of a fully decentralized monetary system, whereby the tokens are created by the nodes of a peer to peer network. The Based Work Token algorithm defines how the token will be created and at what rate.</p>
<p>As with Bitcoin, Based Work Tokens are generated every time a user discovers a new block by submiting a Proof of Work for the current challengeNumber.</p>
<p>A unique &#39;nonce&#39; has to be passed into the mint function along with the hash solution digest in order for tokens to be dispensed. To find this special number, it is necessary to run a mining program. More specifically, the PoW includes a recent zkSync Era block hash combined with the wallet sender&#39;s address in order to prevent man in the middle attacks when minting new coins. The challenge and nonce are validated in solidity using the keccak256 hashing algorithm to decipher the challenge&#39;s digest. Once the digest has been extracted, it is validated to match the expected challenge result and then check to ensure that it is smaller than the mining target difficulty.</p>
<p>The mining reward is calculated based on the logarithmic halving algorithm making the Based Work Token a reliably deflationary asset. The award is immediately assigned to the sender&#39;s wallet address and the ‘tokens minted count’ is incremented within the smart contract for any other software to monitor. Notably, the contract then validates that the tokens minted count is less than or equal to the maximum supply or the given halving era that transaction is taking place. Next, the contract records diagnostics reflecting reward address, amount and ether block number for the purpose of public transparency and for other software to monitor.</p>
<h3 id="difficulty-calculation-and-adjustment">Difficulty Calculation and Adjustment</h3>
<p>After every block is minted, the smart contract will determine if it is time to adjust the difficulty.  This occurs every 2016 mined blocks in the first era.  Just before this occurs, the contract increments the reward era if necessary - this is, if the tokens minted count has exceeded the maximum era supply which is calculated via a simple halving algorithm: </p>
<p>max_era_supply = total_supply - (total_supply / (2 * (reward_era + 1)))</p>
<p>This means that the first era supply was 10500000 tokens, the second era supply is 15750000 tokens, the third era supply is 18375000 tokens and so forth.   During the first era which has already passed the block reward for a mint() was 25 tokens at 10 minute blocks.  During the second era, which is where we start the reward is 25 tokens at 10 minute blocks.  During the third era, the reward is 12.5 tokens and at 10 minutes.  During the forth era, the reward is 6.25 tokens and at 10 minute blocks.  And so on and so on.  There are 59 eras total that will reduce the supply rate.  Increasing past a total possible 21,000,000 tokens, but not by much will end rewards for this proof of work token in 150+ years.  At which time Based Work Token can be used as a decentralized digital currency for Ethereum, zkSync Era, and all Layer 2s.  </p>
<p>The reward era is used to calculate the mining reward.  Next, the Based Work Token smart contract adjusts the difficulty by first determining how much time has passed since the last adjustment.  If less than 12 minutes * 2045 blocks had been mined, Based Work Token is being mined too quickly and the difficulty will increase.  This is accomplished by reducing the size of the ‘target’.  When the target is smaller, valid nonces for minting are more rare and are harder to find for future mining rounds.   Alternatively if Based Work Token is being mined too slowly the target will increase in value in order to make minting more easy to accomplish.  All difficulty targets are bound within minimum and maximum difficulties of 216 and 2234 respectively.</p>
<h3 id="calculating-mining-hashrate">Calculating Mining Hashrate</h3>
<p>To calculate approximate hashrate or approximate time to find a solution, the following equation can be used:</p>
<pre><code>TimeToSolveBlock <span class="hljs-comment">(seconds)</span> = <span class="hljs-comment">(difficulty * 2 ^ 22)</span> / hashrate <span class="hljs-comment">(hashes per second)</span>
</code></pre><h3 id="risks-and-challenges">Risks and Challenges</h3>
<p>Based Work Token is implemented as an Base Blockchain ERC20 token and so its success is largely dependent on the success of the Base Network and Ethereum Network.
<h3 id="frequently-asked-questions">Frequently Asked Questions</h3>
<h4 id="does-zkBitcoin-token-have-its-own-blockchain-">Does Based Work Token have its own Blockchain?</h4>
<p>No. Based Work Token exists on the Base Blockchain as a Smart Contract. This allows it to leverage a faster, more secure and modern crypto environment.</p>
<h4 id="how-does-pool-mining-work-with-zkBitcoin-tokens-">How does pool mining work with Based Work Tokens?</h4>
<p>Essentially the same way that pool mining works for classic Bitcoin, except Based Work Token pools must pay gas fees to the Base network.  </p>
<h4 id="how-often-does-difficulty-update-">How often does difficulty update?</h4>
<p>Every 2016 mints on a challenge OR<br>
A) If there are less than 512 mints on the challenge and 45 days has elapsed, update difficulty after another max of 1 blocks.<br>
B) If there are less than 1024 mints but greater than 512 on the challenge and 60 days has elapsed, update difficulty after another max of 1 blocks.<br>
C) If there are greater than 1024 mints on the challenge and 75 days has elapsed, update difficulty after another max of 1 blocks. </p>
<h4 id="how-does-the-difficulty-update-">How does the difficulty update?</h4>
<p>It increases up to 400% or down 25% Target average adjustment time is 14 days.</p>
<h4 id="will-there-be-a-reward-halvening-event-and-when-">Will there be a reward halvening event and when?</h4>
<p>At 15.75m tokens mined.  Then at half of that remaining reward then half of that remaining, up to 59 iterations.</p>
<h4 id="since-zkBitcoin-token-is-proof-of-work-doesn-t-that-mean-it-is-bad-for-the-environment-">Since Based Work Token is Proof of Work doesn&#39;t that mean it is bad for the environment?</h4>
<p>As long as cryptocurrencies exists, mining will always exist.  Even though mining expends energy, it ultimately reduces corruption in society by providing humanity with decentralized and transparent transactional ledgers.  Therefore the idea similar to humanity having to pay for a gigantic decentralized accounting system or police network which is reducing the widespread financial corruption across the globe.  Just as we pay police officers and accountants for their service, we pay blockchain for its service in the form of energy and computation.</p>
<h3 id="whitepaper-contributors">Whitepaper Contributors</h3>
<ol>
<li>Untouchable2k (contract deployer)</li>
</ol>
<h3 id="references">References</h3>
<p>0xBitcoin WhitePaper, 2018
<a href="https://github.com/0xbitcoin/white-paper/blob/master/README.md">https://github.com/0xbitcoin/white-paper/blob/master/README.md</a></p>
<p>Satoshi Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System, 2009. <a href="http://www.bitcoin.org/bitcoin.pdf">http://www.bitcoin.org/bitcoin.pdf</a>.</p>
<p>Logelin J and 
 communitiy members. ERC 541 - Mineable Token Standard Draft, 2018. <a href="https://github.com/ethereum/EIPs/pull/918">https://github.com/ethereum/EIPs/pull/918</a></p>
<p>Fabian Vogelsteller and Vitalik Buterin. ERC-20 Token Standard, 2015. URL <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md</a>.</p>
<p>TrustNodes. The First PoW Bitcoin Like Token Launches on Ethereum, February 16, 2018. <a href="https://www.trustnodes.com/2018/02/16/first-pow-bitcoin-like-token-launches-ethereum">https://www.trustnodes.com/2018/02/16/first-pow-bitcoin-like-token-launches-ethereum</a></p>
<p>Vitalik Buterin. Ethereum White Paper, 2014. <a href="https://github.com/ethereum/wiki/wiki/White-Paper">https://github.com/ethereum/wiki/wiki/White-Paper</a></p>
<p>Epstien J. Why Proof of Work in Bitcoin Means Proof of Value in the Real World, December 20, 2017. <a href="https://www.neverstopmarketing.com/proof-work-bitcoin-means-proof-value-real-world/">https://www.neverstopmarketing.com/proof-work-bitcoin-means-proof-value-real-world/</a></p>
<p>Bitfury Group Limited. &quot;Proof of Stake versus Proof of Work&quot;, 2015. <a href="http://bitfury.com/content/5-white-papers-research/pos-vs-pow-1.0.2.pdf">http://bitfury.com/content/5-white-papers-research/pos-vs-pow-1.0.2.pdf</a></p>
<p><a href="https://en.bitcoin.it/wiki/Controlled_supply">https://en.bitcoin.it/wiki/Controlled_supply</a></p>
<p>Dai W. &quot;b-money&quot;, 1998. <a href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a></p>
<p>Back A. &quot;Hashcash - a denial of service counter-measure&quot;, 2002. <a href="http://www.hashcash.org/papers/hashcash.pdf">http://www.hashcash.org/papers/hashcash.pdf</a></p>
<p>Cunningham A, Ethereum Co-Founder Announces DAICO, a new ICO Fundraising Model (January 15, 2018). <a href="https://discover.coinsquare.io/investing/daico-new-ico-fundraising-model/">https://discover.coinsquare.io/investing/daico-new-ico-fundraising-model/</a></p>



        </div>














         <!-- Footer begins-->
        
    </div>
    <!--bootstrap stuff, no touchy-->
    <!-- /.container -->

    <!-- jQuery -->
    <script src="js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- Script to Activate the Carousel -->
    <script>
    $('.carousel').carousel({
        interval: 5000 //changes the speed
    })
    </script>
	</div>

  
 
  <style>
/* Footer base styles */
footer {
    background-color: #333;
    color: white;
    padding: 40px 0;
    width: 100%;
}

.footer-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 15px;
}

.footer-row {
    display: flex;
    flex-wrap: wrap;
    margin: 0 -15px;
}

/* Column styles */
.footer-col {
    padding: 0 15px;
    margin-bottom: 30px;
}

.footer-col-metamask {
    flex: 0 0 25%;
    max-width: 25%;
}

.footer-col-about {
    flex: 0 0 25%;
    max-width: 25%;
}

.footer-col-info {
    flex: 0 0 50%;
    max-width: 50%;
}

/* Content styles */
.footer-col h3,
.footer-col h5 {
    margin-bottom: 15px;
}

.footer-col ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.footer-col ul li {
    margin-bottom: 10px;
}

.footer-col a {
    color: white;
    text-decoration: none;
}

.social-links {
    margin-top: 20px;
}

.social-links a {
    margin-right: 15px;
    font-size: 20px;
}

.social-links .fa {
    margin-right: 5px;
}

/* Responsive breakpoints */
@media (max-width: 991px) {
    .footer-col-metamask,
    .footer-col-about {
        flex: 0 0 50%;
        max-width: 50%;
    }
    
    .footer-col-info {
        flex: 0 0 100%;
        max-width: 100%;
        margin-top: 20px;
    }
}

@media (max-width: 767px) {
    .footer-col-metamask,
    .footer-col-about,
    .footer-col-info {
        flex: 0 0 100%;
        max-width: 100%;
    }
}
</style>

<footer>
    <div class="footer-container">
        <div class="footer-row">
            <!-- MetaMask Column -->
            <div class="footer-col footer-col-metamask">
                <h5>Add Token to MetaMask</h5>
                <div>
                    <button type="button" class="zenableEthereumButton22 btn btn-hover color-1 glowing addedstylebutton" style="width: 100%; font-size: 90%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        Add Based Work Tokens
                    </button>
                </div>
            </div>

            <!-- About Column -->
            <div class="footer-col footer-col-about">
                <h3>About</h3>
                <ul>
                    <li><a href="https://basedworktoken.org/howtomine.html">How to Mine</a></li>
                    <li><a href="https://basedworktoken.org/whitepaper.html">Whitepaper</a></li>
                    <li><a href="https://basedworktoken.org/team.html">Contact Us</a></li>
                </ul>
            </div>

            <!-- Info Column -->
            <div class="footer-col footer-col-info">
                <div>
                    <h3>Based Work Token (BWORK)</h3>
                    <h5>A new way to DEFI. Mine it yourself with your CPU/GPU/FPGA/ASIC miner!! All decentralized!!</h5>
                </div>
                <div class="social-links">
                    <a href="https://t.me/basedworktoken" aria-label="Telegram">
                        <i class="fa fa-telegram"></i>
                    </a>
                    <a href="https://twitter.com/basedworktoken/" aria-label="Twitter">
                        <i class="fa fa-twitter"></i>
                    </a>
                    <a href="https://medium.com/@basedworktoken/" aria-label="Medium">
                        <i class="fa fa-medium"></i>
                    </a>
                    <a href="https://github.com/basedworktoken" aria-label="Github">
                        <i class="fa fa-github"></i>
                    </a>
                    <a href="https://discord.gg/QrGNf47ATk" aria-label="Discord">
                        <span>Join Our Discord</span>
                    </a>
                </div>
            </div>
        </div>
    </div>
</footer>
                                   <script>
                                    let accounts = [];
                                    //Sending Ethereum to an address
                                    //
                                    const ethereumButton22ff = document.querySelector('.zenableEthereumButton22');
                                    
                                    ethereumButton22ff.addEventListener('click', () => {
                                      getAccount22ff();
                               
                                   
                                    });
                                    
                                    
                                    async function getAccount() {
                                      accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                                      showAccount.innerHTML = accounts;
                                     console.log(accounts);
                                    }
                                        
                                    
                                    async function getAccount22ff() {
                                            
                                                                
                                          try {
                                              await ethereum.request({
                                                method: 'wallet_switchEthereumChain',
                                                params: [{ chainId: '0x14a34' }],
                                              });
                                            } catch (switchError) {
                                              // This error code indicates that the chain has not been added to MetaMask.
                                              if (switchError.code === 4902) {
                                                try {
                                                  await ethereum.request({
                                                    method: 'wallet_addEthereumChain',
                                                    params: [{ chainId: '0x14a34', 
                                                    chainName: 'Base Sepolia Testnet',
                                                    nativeCurrency: {
                                                        name: 'Ethereum',
                                                        symbol: 'ETH', // 2-6 characters long
                                                        decimals: 18
                                                    },
                                                    blockExplorerUrls: ['https://sepolia.basescan.org'],
                                                    rpcUrls: ['https://sepolia.base.org'] }],
                                                  });
                                                } catch (addError) {
                                                  // handle "add" error
                                                }
                                              }
                                              // handle other "switch" errors
                                            }		
                                                    
                                            await new Promise(r => setTimeout(r, 20));
                                            accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                                            const tokenAddress2 = '0x158A9607FaE8ae0754eF39dE978eA4751A4C6d1f';
                                            const tokenSymbol2 = 'BWORK';
                                            const tokenDecimals2 = 18;
                                            const tokenImage2 = 'https://basedworktoken.github.io/img/zkBitcoin_icon_32px32px.png';
        
                                        
                                               
                                                        
                                                                                               
                                            
                                            try {
                                              // wasAdded is a boolean. Like any RPC method, an error may be thrown.
                                              const wasAdded = await ethereum.request({
                                                method: 'wallet_watchAsset',
                                                params: {
                                                  type: 'ERC20', // Initially only supports ERC20, but eventually more!
                                                  options: {
                                                    address: tokenAddress2, // The address that the token is at.
                                                    symbol: tokenSymbol2, // A ticker symbol or shorthand, up to 5 chars.
                                                    decimals: tokenDecimals2,  // The number of decimals in the token
                                                    image: tokenImage2, // A string url of the token logo
        
                                                  },
                                                },
                                              });

                                              if (wasAdded) {
                                        console.log('Thanks for your interest!');
                                      } else {
                                        console.log('Your loss!');
                                      }
                                    } catch (error) {
                                      console.log(error);
                                    }
                                        }
                                    </script>

</body>

</html>
